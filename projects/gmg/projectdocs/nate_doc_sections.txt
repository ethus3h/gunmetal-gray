Nate's Document Sections

--------------------------------------------------
DESIGN DOCUMENT

Section 2 - Overview of the Game

	This will be a side scrolling action adventure game starring a sheriff in a western world.  The game play will consist of running, jumping, shooting, collecting items, and progressing on an adventure.  There will be environmental obstacles and enemies to overcome.
	An evil villain has captured someone important to the main character and he needs to go and rescue her.  This journey will involve crossing through several different environments, each with their own challenges to overcome.  Along the way, steam powered robots will be trying to put and end to your efforts.
	The game will be played either with the keyboard or with a joystick -- depending on the player's preference.  The screens will scroll to follow the hero throughout each environment as the player jumps over, dodges, and fights through every obstacle.  Doors will be used to link areas together and allow traveling between different places.
	A health indicator will be at the top of the screen and if it runs out, the player will have to try again at completing this area.  The sheriff will respawn at the last checkpoint (outhouses) and any additional progress made after saving would be lost.  There shouldn't be too much distance between each check point, so it shouldn't be too frustrating for the player.
	The player will win the game when he reaches the end, defeats the main villain, and rescues the kidnapped victim.  After completing the game, the player will be rewarded with a cut scene (or slide show) showing how the people of this game world benefited from his accomplishments.


Section 4 - Architecture of the Game

	The team project will be building up from Nathan's project one source code.  Because of this, there is a lot of functionality already available in the game's architecture.  Of course, more will be added to it to provide more features that can be usable in the game's design.
	A configuration file is loaded at the beginning of the game to provide players with a few customization options.  Currently these options include changing the screen scaling, setting the display to full screen, the player's input methods (joystick or keyboard), and customizing the key and button bindings.  Allowing the player to change audio volume might be added in the future.  An interesting option, that would be useful for full screen, is allowing the player to set the window resolution and the game could try to automatically adjust the scaling and positioning UI elements to work well with the change.  This is a low priority option at the moment, though.
	There is functionality for loading and saving the player's progress.  A new format for the data will be determined for working with the new game design, but it should be easily to make the necessary changes.  This feature will be able to track the player's accomplishments, changes made in the game world and story, and inventory to allow the player to continue where he left off during an earlier play session.
	Currently the game engine can easily handle switching between different game states.  These states might include the title screen, maybe an options screen, cut scenes, dialog with characters, pausing the game, possibly mini-games, and debugging mode.  It has not yet been finalized exactly what game states will be needed, but the system is flexible enough to simply plug in a new state whenever we feel like adding one.
	There is already the start of a controller based UI system that could be expanded on later to include more features.  The up and direction keys are used to select menu items and the fire button is used to interact with the current selection.  More widgets might be added as needed.  A few UI based game states will be added, like a dialog state that shows conversations between the characters in the game.
	A debugging mode is currently available which shows in game information overlaid on top of the action.  More features and functionality could be added to this to display more information and to allow for game play testers to manipulate some values and objects during run-time.  For example, it may be possible to add a command line to the bottom of the screen that can be used to enter commands for loading maps, spawning objects, setting values in objects, and more.  Likely, though, we will not get too fancy with this, though, since it doesn't have a direct impact on anything a player might actually be interacting with.
	The game engine already handles resource loading and caching.  When a new file is needed it checks if it is already loaded into memory and, if it is not, it loads it and optionally stores the data for easy retrieval later.  This is done for images, sounds, animations, text based data, and a few other things.  Some features that should be added in the future may include clearing out resources that are no longer being used.  For example, after a new map is loaded it could delete some of the stuff from the previous map that are no longer needed.  Another feature that needs to be added is a music management system to make it easier to switch between musical scores during different moments during gameplay.
	There is functionality for handling frame based animations, like sprite animations, and also animating interpolated values, like moving between points on a path.  Some possible work that could be done is to load in more animation types than just sprite based animations.  Composite sprite animation, where a large object might be broken into smaller images that can move independently from each other, might be a useful feature for large boss type enemies.  We would have to figure out, though, if we'll be able to find or develop a tool that would simplify making these animations.
	The game engine can load and draw tile maps with multiple layers of tile map data.  These layers can be moved at different speeds to give the illusion of depth while the camera pans around.  The tile map format also includes object layers that can be used for positioning in game objects and configuring their parameters.  This would make the creation of new areas relatively simple.
	With the current game object management system, it is easy to add, remove, and interact with game objects.  All of the game objects will be composed of reusable components along with behavior code describing how these components should interact.  These components abstract away the interactions between game objects and other parts of the game engine.  For example, one component is used for displaying animated sprite graphics.  The programmer does not need to know how this component works or what parts of the game engine it interacts with, he only needs to know how to update it and what sort of behaviors can be expected from it.
	A sprite collision component can be used to handle the interactions between sprites when they touch each other.  A game object does not need to know what sort of other object it is touching, though, it only needs to inform the other object about what kind of interaction should take place.  For example, if there is a fire object it would tell any object touching it that it is touching fire.  Those other objects could then decide for themselves how to respond or they could simply ignore it.  A piece of paper might burn up and be destroyed, but a stone might not do anything.  Objects only need to implement the interactions that they care about responding to.
	Other components implement basic physics and terrain collisions.  The velocity in the physics component of an object can be set and it will be launched along a trajectory with gravity pulling it down.  The map collision component can then be used while moving the object to prevent penetration into the ground, walls, and ceiling.  Once again, the programmer does not need to know the exact details of how these work and, in fact, we might want to revise some of the code for this.
	As can be seen, the base code we are starting from is quite functional.  This would hopefully allow us to focus more time on game design, creating assets, and implementing game objects that could populate our game world.  A lot of work has already been done, but there is still a lot more work to do before it's over.


Section 5 - Scope of Effort

	With some of the ideas we've been kicking around, the scope of this project might be a bit larger than it should be.  The good news is, we are not starting with a blank slate, so hopefully that would allow us to focus our attention on creating what needs to be put into the game -- like maps, game objects, and other assets.  We should focus first on getting the most important core aspects of the game in place before trying to add in all the extra little things.
	We have plans for at least five or more different environments, and some ideas for activities that can take place in these areas.  Creating these environments would require designing tile sets and decorative set pieces along with the game objects specific to these areas.  For example, deserts would have a sandy and rocky looking tile map that is decorated with cacti and tumble weed objects might be made to roll around these areas.  Other than deserts we talked about caves, gold mines, small towns, and the evil villainâ€™s secret base.
	A number of different enemies and bosses have been discussed with different behaviors and animations.  These might take some time to make, so we will be beginning with a few of the most important enemies first and then seeing how much time we have for adding more into the game.  Most enemies may simply be variations of some of the other enemies, which should help save some time creating them.
	There are also some plans for a few interactive objects used in some of the levels, characters that can be talked to, items that can be collected, and a few tools that can be used in certain areas.  There may also be a simple story, but nothing too elaborate.
	That's quite a lot of work for the amount of time we have left, so we should be aiming to at least complete one area of the game and then see what we have time for after that.  It certainly is not impossible to achieve something interesting and fun to play, but we shouldn't be expecting to be able to accomplish everything we've been thinking of adding and that's okay.


--------------------------------------------------
TESTING DOCUMENT

Section 1 - Introduction

	This project will be a side scrolling action adventure in the style of a western with steam powered robots.  It will be similar in gameplay to many older games like for the Nintendo and Super Nintendo Entertainment Systems.  The primary goal of the game, that the player will be working towards, is to get to the end, defeat the villain, and rescue someone who had been kidnapped.  See the design document for a more thorough explanation of the game's design.
	This testing document will outline ways this game will be tested during development.  Some of these methods might include some logging, stepping through the program with a debugger, exception handling, a debug mode during game play, and possibly unit testing.  There may also be a few simple tools designed for validating some of the content created for the game to make sure it is formatted correctly.
